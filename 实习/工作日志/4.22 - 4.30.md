# 迭代任务

1. 完成`LFileSystemPath`和`LFileSystemEntry`的编写，自测无误后已经转测
2. 对比`std::map`和`QMap`的接口

# 对比std::map和QMap

1. 构造函数

   - `std::map`提供了很多版本，但是很多都和用户的使用没有关系，比如传入迭代器，分配器等，因此下面只看`QMap`

   - 默认构造：略

   - 带参构造、拷贝构造和移动构造：通过`initializer_list`构造，通过`std::map`和`QMap`进行拷贝和移动构造

   ```cpp
   QMap(std::initializer_list<std::pair<Key, T>> list);
   QMap(const std::map<Key, T> &other);
   QMap(std::map<Key, T> &&other);
   QMap(const QMap<Key, T> &other);
   QMap(QMap<Key, T> &&other);
   ```

2. 析构函数：略

3. 迭代器：首尾，反转首尾

   - 应该提供非常量迭代器和常量迭代器的版本，接口包括`begin()`、`end()`、`rbegin()`、`rend()`

   ```cpp
   QMap<Key, T>::iterator begin();
   QMap<Key, T>::const_iterator begin() const;
   QMap<Key, T>::const_iterator cbegin() const;
   QMap<Key, T>::const_iterator cend() const;
   QMap<Key, T>::const_iterator constBegin() const; // begin() 返回常量迭代器的别名
   QMap<Key, T>::const_iterator constEnd() const; // cend() 返回常量迭代器的别名
   ```

4. `clear()`：略

5. `constFind()`：通过`key`找到迭代器，返回常量迭代器

   ```cpp
   QMap<Key, T>::const_iterator constFind(const Key &key) const;
   ```

6. `contains()`：判断`key`是否在`map`中

   ```cpp
   bool contains(const Key &key) const;
   ```

7. `count()`：返回指定`key`的元素个数，在`map`中`key`无法重复，值只能是`0`或`1`

   - 第二个重载，返回整个`map`的大小，即`size()`

   ```cpp
   QMap<Key, T>::size_type	count(const Key &key) const;
   QMap<Key, T>::size_type	count() const;
   ```

8. `empty()`：判空，略

   - `isEmpty()`是`empty()`的别名

9. `equal_range()`：找到和给定`key`相同的迭代器的范围，满足左开右闭的规则

   ```cpp
   std::pair<QMap<Key, T>::iterator, QMap<Key, T>::iterator> equal_range(const Key &key);
   std::pair<QMap<Key, T>::const_iterator, QMap<Key, T>::const_iterator> equal_range(const Key &key) const;
   ```

10. `erase()`：删除元素

    - 第二个重载版本，由于`map`默认是会自动排序的，因此遍历的结果是有序的（`unorder_map`的哈希的遍历结果不一定是有序的，因为经过插入或者删除的哈希桶结构会发生变化，因此两个`unorder_map`的元素是相同的情况下遍历的结果也可能会不同，但是`map`底层是红黑树，元素是有固定的顺序的，因此结果有序），因此可以通过迭代器删除区间的元素

    ```cpp
    QMap<Key, T>::iterator erase(QMap<Key, T>::const_iterator pos);
    QMap<Key, T>::iterator erase(QMap<Key, T>::const_iterator first, QMap<Key, T>::const_iterator last);
    ```

11. `find()`：通过`key`，查找并返回迭代器

    ```cpp
    QMap<Key, T>::iterator find(const Key &key);
    QMap<Key, T>::const_iterator find(const Key &key) const;
    ```

12. `first()`、`firstKey()`：返回首元素或者首元素的`key`

    - 对应的有`last`系列函数

    ```cpp
    T& first();
    const T& first() const;
    const Key& firstKey() const;
    T& last();
    const T& last() const;
    const Key& lastKey() const;
    ```

13. `insert()`：根据`key`和`value`插入到`map`中

    - 第四个重载版本，个人认为没有必要，`const &`本身就是万能引用，既能接受左值，又能接受右值

    ```cpp
    QMap<Key, T>::iterator insert(const Key &key, const T &value);
    QMap<Key, T>::iterator insert(QMap<Key, T>::const_iterator pos, const Key &key, const T &value);
    void insert(const QMap<Key, T> &map);
    void insert(QMap<Key, T> &&map);
    ```

14. `keys()`：返回`key`的列表

    - 第二个重载版本，返回指定`value`对应的`key`列表，因为`key`不重复，`value`当然可能

    ```cpp
    QList<Key> keys() const;
    QList<Key> keys(const T &value) const;
    ```

15. `values()`：导出`value`列表，略

16. `key()`：根据`value`找到对应第一个的`key`

    - 第二个参数，用户可以自己给定如果`value`不存在，返回的`key`值，否则返回默认值

    ```cpp
    Key key(const T &value, const Key &defaultKey = Key()) const;
    ```

17. `value()`：根据`key`找到对应的第一个`value`，第二个参数同上

    ```cpp
    T value(const Key &key, const T &defaultValue = T()) const;
    ```

18. `lowerBuond()`和`upperBound()`：通过二分有序查找指定的元素

    - 例子：`1,2,2,2,3`（当然`map`是去重的，这里只是明确语义），`key==2`

    - `lowerBound()`：找到大于等于`key`的第一个元素，这里就是第一个`2`
    - `upperBound()`：个人认为是找到不大于`key`的最后一个元素，也就是最后一个`2`，但是根据标准库和迭代器的语义，返回的是`3`，也就是大于`key`的第一个元素

    ```cpp
    QMap<Key, T>::iterator lowerBound(const Key &key);
    QMap<Key, T>::const_iterator lowerBound(const Key &key) const;
    QMap<Key, T>::iterator upperBound(const Key &key);
    QMap<Key, T>::const_iterator upperBound(const Key &key) const;
    ```

19. `remove()`和`removeIf()`

    - 第二个重载版本，根据传入的谓词进行删除

    ```cpp
    QMap<Key, T>::size_type remove(const Key &key);
    QMap<Key, T>::size_type removeIf(Predicate pred);
    ```

20. `size()`：返回大小，略

21. `swap()`：与另一个`map`对象进行交换，略

22. `toStdMap()`：导出为`std::map`，略

    ```cpp
    T value(const Key &key, const T &defaultValue = T()) const;
    ```

23. `operator=()`：拷贝和移动赋值函数

    ```cpp
    QMap<Key, T>& operator=(const QMap<Key, T> &other);
    QMap<Key, T>& operator=(QMap<Key, T> &&other);
    ```

24. `operator[]()`：`[]`运算符重载

    - 个人认为第二个返回值的版本没有意义，这两个在实际接受的时候没有办法进行合理区分，建议改为`const T&`

    ```cpp
    T& operator[](const Key &key);
    T operator[](const Key &key) const;
    ```

25. `key_iterator`

    - `Qt`提供了一个专门用于遍历`key`的迭代器
    - 个人认为完全没有必要，提供最普通的迭代器就完事了

    ```cpp
    QMap<Key, T>::key_iterator keyBegin() const;
    QMap<Key, T>::key_iterator keyEnd() const;
    ```

26. `key_value_iterator`

    - 经查询，`Qt`提供了一个`STL Style`的迭代器，为了可以被`STL`的`Algorithm`进行调用

    ```cpp
    QMap<Key, T>::key_value_iterator keyValueBegin();
    QMap<Key, T>::const_key_value_iterator keyValueBegin() const;
    QMap<Key, T>::key_value_iterator keyValueEnd();
    QMap<Key, T>::const_key_value_iterator keyValueEnd() const;
    QMap<Key, T>::const_key_value_iterator constKeyValueBegin() const;
    QMap<Key, T>::const_key_value_iterator constKeyValueEnd() const;
    ```

27. `asKeyValueRange()`

    - `TODO`

