# 1.29 - 2.8

# 迭代任务

- 重构代码`LStack`，`LQueue`
- 走查代码`LObject`，`LApplication`，`LSignal`

# 任务1

- 经过和钟老师商量，决定保留`public`继承的方式，不做覆盖，因为`Qt`也是这么做的，对于是隐藏父类不需要的功能还是保留，为了减少工作量，选择了保留，这个哲学问题留后续商榷
- 目前已经完成初步重构，已经转测

# 任务2

## LObject

- 这个类是所有类的基类，提供了`3种`非常重要的功能：对象树机制、动态属性功能、信号槽机制

### 对象树机制

#### 学习的点

- 我们在构造对象的时候，为了方便内存的管理和释放，将所有的对象之间建立关系，每个对象都有父对象和子对象（当然最终的父对象没有），比如`LButton`显然就是`LWindow`的子对象，如此以以来就形成了一颗多叉树

- 用一张图理解

  <img src="https://img-blog.csdnimg.cn/direct/f9332ae3aee845c0b4306bed0d62f669.png" alt="image-20240130141713776" style="zoom:75%;" />

- 优点：能够做到很好的内存释放，我们确定的父对象，当父对象释放的时候，子对象也必须跟着释放，例如`LWindow`没了，那`LButton`肯定也没了，对象树的功能就是父对象在释放的时候，会首先和他的父对象断开联系，然后释放以自己为根的这颗多叉树，从最下面的子对象开始依次向上释放，最终释放自身，有点`Java`的`gc`的感觉，如果不做处理的话，尤其是在堆上开辟的空间管理将会非常混乱；同时个人认为在`GUI`编程中用的非常频繁

- 疑问：在对象树当中，所有的对象为什么都必须处于同一个线程？

- 翻帖子的时候看到一个有意思的程序（重复析构）

  ~~~cpp
  // main.cpp
  int main()
  {
      // 用户编码行为不规范
      QPushButton quit("Quit");
      QWidget window;
   
      quit.setParent(&window);
  }
  ~~~

- 判断对象是否是`new`出来的

  - 重载`new`运算符，对类重载`new`运算符，在外部调用`new`的时候会优先考虑重载的版本
  - 在这里重载之后，将类内部的数据全部填充为`'L'`

  <img src="https://img-blog.csdnimg.cn/direct/5bd53105965449338f5dfac3e06d8376.png" alt="image-20240130163612435" style="zoom:75%;" />

  - 我们预留了一块内存判断区域，这时候`new`的实际操作顺序是，先调用我们的重载版本的`new`，然后强转为本类指针被接受，然后调用构造函数，因此在构造的时候其他数据段会进行初始化，而内存判断区不会，问题解决

    <img src="https://img-blog.csdnimg.cn/direct/51f96fa3c32f419989240c71a2f6c11c.png" alt="image-20240130164008701" style="zoom:70%;" />


#### 代码走查的问题

- 用`LList`替代`std::list`

  - `LList`目前并未走查，也并未针对问题重构，代码健壮程度不如`LVector`，但是选用`LVector`的话由于二者接口名称的不同，可能需要改动的工作量较大

  <img src="https://img-blog.csdnimg.cn/direct/d46d3523e8954523aa83ff550b93bb0a.png" alt="image-20240130145951498" style="zoom:80%;" />

  <img src="https://img-blog.csdnimg.cn/direct/4ec783ae9ab844fea2bfdf3a35681a1f.png" alt="image-20240130150016313" style="zoom:80%;" />

- `RTTI`机制

  <img src="https://img-blog.csdnimg.cn/direct/99913101ecc344f4bcf94186e27cb96c.png" alt="image-20240130165250475" style="zoom:77%;" />

  - 我能想到的就是`typeinfo().name()`，它的返回值是有一定规律的，不管是对于内置类型还是自定义类型，还有模板的类，做一个算法解析，然后在构造函数的时候调用即可

### 动态属性功能

- 首先看`Qt`的属性机制，给我总的看法：我觉得很震惊，甚至感觉有点脱裤子放屁

- 属性声明依托于`Q_PROPERTY`宏

  - 最核心的功能：为类内的成员属性很方便的设置一个`getter`和`setter`方法，当然还有一些其他的附加方法

    <img src="https://img-blog.csdnimg.cn/direct/00dc69c82dd5495f91d42501bfedeafb.png" alt="image-20240130152909683" style="zoom:78%;" />

  - 我自己用`Qt`写了一个`demo`做演示

- 动态属性和静态属性

  - 除了类当中原本就存在的属性，在程序运行的时候还可以运行时插入新的属性，这就是动态属性和静态属性的区别

- 与我们的进行对比

  - 个人认为`Qt`这么做的最大目的就是将属性的`getter`和`setter`方法做接口的统一，也就是使用`property`和`setProperty`，`Qt`用了这个宏的方法实现了基础功能和更加复杂的多样化功能
  - 但对于我们目前而言，我觉得能够做到`getter`和`setter`就可以了，我们使用了`LVector<PropertyStruct*>`来存储构成存储动态属性的数组

### 信号槽机制

## LApplication

## LSignal

