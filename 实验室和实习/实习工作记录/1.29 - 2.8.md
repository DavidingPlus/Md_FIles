# 1.29 - 2.8

# 迭代任务

- 重构代码`LStack`，`LQueue`
- 走查代码`LObject`，`LApplication`，`LSignal`

# 任务1

- 经过和钟老师商量，决定保留`public`继承的方式，不做覆盖，因为`Qt`也是这么做的，对于是隐藏父类不需要的功能还是保留，为了减少工作量，选择了保留，这个哲学问题留后续商榷
- 目前已经完成初步重构，已经转测

# 任务2

## LObject

- 这个类是所有类的基类，提供了`3种`非常重要的功能：对象树机制、动态属性功能、信号槽机制

### 对象树机制

#### 学习的点

- 对象树机制

  - 我们在构造对象的时候，为了方便内存的管理和释放，将所有的对象之间建立关系，每个对象都有父对象和子对象（当然最终的父对象没有），比如`LButton`显然就是`LWindow`的子对象，如此以以来就形成了一颗多叉树


  - 用一张图理解

    <img src="https://img-blog.csdnimg.cn/direct/f9332ae3aee845c0b4306bed0d62f669.png" alt="image-20240130141713776" style="zoom:75%;" />


  - 优点：能够做到很好的内存释放，我们确定的父对象，当父对象释放的时候，子对象也必须跟着释放，例如`LWindow`没了，那`LButton`肯定也没了，对象树的功能就是父对象在释放的时候，会首先和他的父对象断开联系，然后释放以自己为根的这颗多叉树，从最下面的子对象开始依次向上释放，最终释放自身，有点`Java`的`gc`的感觉，如果不做处理的话，尤其是在堆上开辟的空间管理将会非常混乱；同时个人认为在`GUI`编程中用的非常频繁


  - 疑问：在对象树当中，所有的对象为什么都必须处于同一个线程？


  - 翻帖子的时候看到一个有意思的程序（重复析构）

    ~~~cpp
    // main.cpp
    int main()
    {
        // 用户编码行为不规范
        QPushButton quit("Quit");
        QWidget window;
     
        quit.setParent(&window);
    }
    ~~~


- 判断对象是否是`new`出来的

  - 重载`new`运算符，对类重载`new`运算符，在外部调用`new`的时候会优先考虑重载的版本
  - 在这里重载之后，将类内部的数据全部填充为`'L'`

  <img src="https://img-blog.csdnimg.cn/direct/5bd53105965449338f5dfac3e06d8376.png" alt="image-20240130163612435" style="zoom:75%;" />

  - 我们预留了一块内存判断区域，这时候`new`的实际操作顺序是，先调用我们的重载版本的`new`，然后强转为本类指针被接受，然后调用构造函数，因此在构造的时候其他数据段会进行初始化，而内存判断区不会，问题解决

    <img src="https://img-blog.csdnimg.cn/direct/51f96fa3c32f419989240c71a2f6c11c.png" alt="image-20240130164008701" style="zoom:70%;" />

- `RTTI`机制

  - `RTTI`机制（`Runtime Type Identification`），运行时类型识别，主要是在用在多态里面，程序能使用基类的指针来识别实际使用的派生类类型

  - `dynamic_cast`：主要将基类指针安全的转化为派生类指针

    ~~~cpp
    // dynamic_cast
    Animal* dog = new Dog;
    
    // 检查dog的类型
    // 如果能安全转换返回转换后的指针，不则返回空指针或者抛出异常
    Dog* res = dynamic_cast<Dog*>(dog);  // success
    if (res)
        std::cout << "Dog success.\n";
    
    Cat* res2 = dynamic_cast<Cat*>(dog);  // fail
    if (res2)
        std::cout << "Cat success.\n";
    ~~~

  - `typeinfo`类：`typeinfo`类将构造函数，拷贝构造，移动构造等全部都删除了，因此不能实例化，其中含有方法name()，==，!=，使用`typeinfo`的唯一方式是通过关键字`typeid`

    ~~~cpp
    int a = 1;
    
    // 不同的编译器输出的结果不同，Ubuntu下这里返回的是 i
    std::cout << typeid(a).name() << '\n';
    
    // 但是尽管编译器的实现存在差异，typeid是可以进行==号和!=号的比较的
    std::cout << (typeid(a) == typeid(int)) << '\n';     // true
    std::cout << (typeid(a) == typeid(double)) << '\n';  // false
    
    // typeid作用于自定义类
    // 可以看出是有一定规律的，可以在构造函数的时候做一定解析存入类中
    std::cout << typeid(Animal).name() << '\n';  // 6Animal
    std::cout << typeid(Dog*).name() << '\n';    // P3Dog
    std::cout << typeid(Cat**).name() << '\n';   // PP3Cat
    ~~~



#### 代码走查的问题

- `Release`函数当中是释放子对象的过程感觉有点问题

  - 子对象可能也有自己的子对象列表，所以应该按照递归的方式去调用，当本对象没有子对象才做真正的释放，这样感觉合理一些

  <img src="https://img-blog.csdnimg.cn/direct/11885be8f8ee4a418754af4af73f0383.png" alt="image-20240204111431725" style="zoom:75%;" />

- 用`LList`替代`std::list`

  - `LList`目前并未走查，也并未针对可能存在的问题修改或重构，代码健壮程度不如`LVector`，但是选用`LVector`的话由于二者接口名称的不同，可能需要改动的工作量较大

  <img src="https://img-blog.csdnimg.cn/direct/d46d3523e8954523aa83ff550b93bb0a.png" alt="image-20240130145951498" style="zoom:80%;" />

  <img src="https://img-blog.csdnimg.cn/direct/4ec783ae9ab844fea2bfdf3a35681a1f.png" alt="image-20240130150016313" style="zoom:80%;" />

- `RTTI`机制

  <img src="https://img-blog.csdnimg.cn/direct/99913101ecc344f4bcf94186e27cb96c.png" alt="image-20240130165250475" style="zoom:77%;" />

  - 我能想到的就是`typeinfo().name()`，它的返回值是有一定规律的，当然我们这里是用作自定义类类名的存储，做一个算法解析，然后在构造函数的时候调用即可

### 动态属性功能

- 首先看`Qt`的属性机制，给我总的看法：我觉得很震惊，甚至感觉有点脱裤子放屁

- 属性声明依托于`Q_PROPERTY`宏

  - 最核心的功能：为类内的成员属性很方便的设置一个`getter`和`setter`方法，当然还有一些其他的附加方法

    <img src="https://img-blog.csdnimg.cn/direct/00dc69c82dd5495f91d42501bfedeafb.png" alt="image-20240130152909683" style="zoom:78%;" />

  - 我自己用`Qt`写了一个`demo`做演示

- 动态属性和静态属性

  - 除了类当中原本就存在的属性，在程序运行的时候还可以运行时插入新的属性，这就是动态属性和静态属性的区别

- 与我们的进行对比

  - 个人认为`Qt`这么做的最大目的就是将属性的`getter`和`setter`方法做接口的统一，也就是使用`property`和`setProperty`，`Qt`用了这个宏的方法实现了基础功能和更加复杂的多样化功能
  - 但对于我们目前而言，我觉得能够做到`getter`和`setter`就可以了，我们使用了`LVector<PropertyStruct*>`来存储构成存储动态属性的数组

### 信号槽机制

- 关于信号槽机制原理见`LSignal`中

- 存储连接到本对象某个槽函数的所有信号列表

  <img src="https://img-blog.csdnimg.cn/direct/e531aff118874edab705740b80269531.png" alt="image-20240201142729430" style="zoom:65%;" />

- 事件处理接口`event()`，可以处理定时器事件和信号槽事件，我关心信号槽事件，涉及到类`LSignalEvent`，见下面

## LApplication

### 学习的点

- 单例模式
  - 不管有多少个`Window`，只能有一个`Application`实例，这个实例在一个进程中有且只能只有一个
  
  - 简单的单例程序
  
    ~~~cpp
    // singleton.h
    #ifndef _SIGLETON_H_
    #define _SIGLETON_H_
    
    #include <iostream>
    
    class Singleton {
    public:
        static Singleton* getInstance();
    
        void print();
    
    protected:
        Singleton() = default;
        virtual ~Singleton() = default;
    
        Singleton(const Singleton&) = delete;
        Singleton& operator=(const Singleton&) = delete;
    
        Singleton(Singleton&&) = delete;
        Singleton& operator=(Singleton&&) = delete;
    
    private:
        static Singleton* m_instance;
    };
    
    #endif
    ~~~
  
    ~~~cpp
    // singleton.cpp
    #include "singleton.h"
    
    Singleton* Singleton::m_instance = nullptr;
    
    Singleton* Singleton::getInstance() {
        if (nullptr == m_instance)
            m_instance = new Singleton();
        return m_instance;
    }
    
    void Singleton::print() {
        std::cout << "address: " << m_instance << '\n';
    }
    ~~~

- 单例与多态结合

  - 在构造`Application`的时候，构造单例平台相关接口，平台接口返回平台相关的一些信息，也是单例

    <img src="https://img-blog.csdnimg.cn/direct/367ef6de2c8b44c2a6afdcca56fddd37.png" alt="image-20240131143154853" style="zoom:75%;" />

  - `LPlatformInterface`派生出`LLinuxInterface`和`LWin32Interface`，并且`LPlatformInterface`是一个抽象类，它内部的平台相关功能在派生类覆写，通用功能自己写了，并且它也是一个单例模式，因此派生类也是单例

  - 抽象类无法实例化，但是我们构造`Application`的时候已经实例化出平台相关的派生类单例对象了；这时候多态就派上用场了，由于单例指针的唯一性，我们通过基类方法获得的指针，进而调用的方法就是平台相关的派生类方法，这就是多态

  - 简单的多态程序

    ~~~cpp
    #include <iostream>
    using namespace std;
    
    class Animal {
    public:
        virtual void bite() = 0;
    };
    
    class Dog : public Animal {
    public:
        void bite() { cout << "Dog bite" << endl; }
    };
    
    class Cat : public Animal {
    public:
        void bite() { cout << "Cat bite" << endl; }
    };
    
    int main() {
        Animal *dog = new Dog();
        dog->bite();
    
        Animal *cat = new Cat();
        cat->bite();
    
        return 0;
    }
    ~~~

- 事件机制（简单理解）

  - 我们的程序是通过事件循环进行轮询，不断检查是否有新的事件发生；发生之后，添加到一个事件队列中，事件循环再依次处理
  - 每个线程都有自己的事件循环，`Application`是我们的主程序框架，在这就是主线程和主事件循环，主事件循环主要处理与用户界面相关的事件，当然还有所有事件的管理和分发；其他工作线程处理各自的任务，这样可以极大的提高效率
  - 但是事件机制（`event`）在我们的代码里面如何应用，目前我看不懂。。。
  - 当然主程序框架为主事件循环提供了几个接口，例如`exec()`，`quit()`等

### 代码走查的问题

- `LApplication`和`lplatforminterface`的移动构造和移动赋值函数的参数应该不需要带上`const`

  - 右值引用代表进来的是一个将亡对象，一般写移动的内部实现是将二者的数据区`swap`，这样原来的数据区就会被自动回收，这样可以减少拷贝的次数，所以应该没有`const`

  <img src="https://img-blog.csdnimg.cn/direct/dfaad54b9e4a45af9578faf4ab2ffd33.png" alt="image-20240131142031853" style="zoom:73%;" />

  <img src="https://img-blog.csdnimg.cn/direct/ec38729233b643e898eba10708153b20.png" alt="image-20240131141725174" style="zoom:72%;" />

- 代码中的`TODO`

  <img src="https://img-blog.csdnimg.cn/direct/f48f49f888ca4bfd986142f2c7012a67.png" alt="image-20240131144606076" style="zoom:75%;" />

## LSignal

### 学习的点

- 信号槽机制

  - 信号槽机制的作用是当将某个信号函数和某个响应的槽函数绑定在一起的时候，当我的信号被触发的时候，就会自动触发对应的槽函数进行响应，比如点击`button`，触发的信号是`clicked`，可以关闭整个窗口，这里的槽函数就是`close()`

- `LSignal`类

  - 信号类，这个类用作信号槽的管理，里面有方法`connect`，`emit`，`disconnect`等

  - `connect`函数

    - 做了两个重载，为了区分类对象的成员函数和普通函数（比如`lambda`）

    - 测试程序

      ~~~cpp
      // ./snippet/SignalEmitTest/main.cpp
      #include <iostream>
      
      #include "lobject.h"
      #include "lsignal.h"
      
      class Test : public LObject {
      public:
          Test() = default;
          ~Test() = default;
      
          void run(int num) { std::cout << "class function: " << num << '\n'; }
      };
      
      void test1();
      
      int main() {
          test1();
      
          return 0;
      }
      
      void test1() {
          LSignal<int> s;
      
          // 为该信号绑定槽函数
          // 类成员对象函数
          Test t;
          s.connect(&t, &Test::run);
      
          // 普通函数
          s.connect([](int num) {
              std::cout << "lambda: " << num << '\n';
          });
      
          s.emit(1);  // 触发信号
      }
      ~~~

    - `connect`函数的作用是把槽函数加入到自身的槽函数列表中

    <img src="https://img-blog.csdnimg.cn/direct/5f64256ecc21488582c3e202334bc1ab.png" alt="image-20240201110235491" style="zoom:75%;" />

    - `emit`函数的作用是发送信号，然后通过事件系统进行槽函数的调度
    - `disconnect`函数就很简单了，就是删除对应的槽函数

- `LSignalConnection`

  - 真正做工作的信号连接类，是将信号发出，调度槽函数执行
  - 为了区分类的成员函数和普通函数，做了一个简单的多态
    - `LSignalConnection` -> `LSignalConnectionToMethod`（类的成员函数） 和 `LSignalConnectionToFunction`（普通函数）
    - 对于两种情况分别处理

### 代码走查的问题

- 关于`LSignalBase`类

  - 注释中写到：基类从实际的信号类中剥离泛型特性，方便使用统一的基类指针来实现信号列表的记录
  - 但是实际上只有一个`LSignal`继承它，并且覆写了一些方法，在`LSignal`中存储`LSignalConnection`维护槽函数相关的信息，槽函数分为成员函数和普通函数，二者的使用具有一定的区别，因此在`LSignalConnection`这里用到了多态，才是使用基类指针管理派生类
  - 个人认为`LSignalBase`的存在有一些多余，当然目前能用
  
- 阅读到`LSignalEvent`的代码时候，没有对类的成员函数做相应处理（参见`LSignalConnection`），导致写`demo`时加上注释这一段编译不通过，测试程序在`./snippet/SignalEmitTest`，具体对比`LSignal`对两种类型的槽函数的不同处理

  <img src="https://img-blog.csdnimg.cn/direct/097ccd86696340c899b20ca175f6d3ae.png" alt="image-20240201142537356" style="zoom:75%;" />

